{{>licenseInfo}}
#include "{{packageName}}/ApiClient.h"

#define CURL_NO_OLDIES
#include <curl/curl.h>

#include <array>
#include <functional>
#include <limits>
#include <memory>
#include <sstream>
#include <stdexcept>

#include "{{packageName}}/ModelBase.h"

class CurlSList {
public:
    void Append(const char *data) {
        if (auto newList = curl_slist_append(m_list.get(), data); newList != nullptr) {
            m_list.release();
            m_list = std::unique_ptr<struct curl_slist, CurlSListCleanup>(newList);
        }
    }

    struct curl_slist *get() {
        return m_list.get();
    }

private:
    struct CurlSListCleanup {
        void operator()(struct curl_slist *handle) const {
            curl_slist_free_all(handle);
        }
    };

    std::unique_ptr<struct curl_slist, CurlSListCleanup> m_list{nullptr};
};

class CurlHandle {
public:
    void AppendHeader(const char *header) {
        m_headers.Append(header);
    }

    CURL *getCurlHandle() {
        return m_handle.get();
    }

    struct curl_slist *getHeaders() {
        return m_headers.get();
    }

private:
    struct CurlCleanup {
        void operator()(CURL *handle) const {
            curl_easy_cleanup(handle);
        }
    };

    std::unique_ptr<CURL, CurlCleanup> m_handle{ curl_easy_init() };
    CurlSList m_headers;
};

{{#apiNamespaceDeclarations}}
namespace {{this}} {
{{/apiNamespaceDeclarations}}

using namespace {{modelNamespace}};

ApiClient::ApiClient(std::shared_ptr<const ApiConfiguration> configuration )
    : m_Configuration(configuration) {
}

std::shared_ptr<const ApiConfiguration> ApiClient::getConfiguration() const {
    return m_Configuration;
}
void ApiClient::setConfiguration(std::shared_ptr<const ApiConfiguration> configuration) {
    m_Configuration = configuration;
}


std::string ApiClient::parameterToString(std::string value) {
    return value;
}

std::string ApiClient::parameterToString(int32_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(uint32_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(int64_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(uint64_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(float value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(double value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(bool value) {
    return value ? "true" : "false";
}

static std::string urlEscape(CURL *handle, const std::string &str) {
    auto escaped = curl_easy_escape(handle, str.c_str(), static_cast<int>(str.length()));

    if (escaped == nullptr) {
        return "";
    }

    std::string result;

    try {
        result = escaped;
    } catch (const std::bad_alloc &) {
        curl_free(escaped);
        throw;
    }

    curl_free(escaped);
    return result;
}

static std::string CreateUrlEncodedParameterString(CURL *handle,
        const std::map<std::string, std::string, std::less<>> &params) {
    std::string paramsStr;

    for (const auto &[key, value] : params) {
        if (!paramsStr.empty()) {
            paramsStr += "&";
        }

        paramsStr += urlEscape(handle, key);

        if (!value.empty()) {
            paramsStr += "=" + urlEscape(handle, value);
        }
    }

    return paramsStr;
}

static std::string BuildTargetUrl(CURL *handle,
        const std::string &base, const std::string &path,
        const std::map<std::string, std::string, std::less<>> &queryParams) {
    std::string url = base + path;

    if (!queryParams.empty()) {
        url += "?" + CreateUrlEncodedParameterString(handle, queryParams);
    }

    return url;
}

static size_t writeDataCallback(const char *data, size_t size, size_t nmemb,
        std::string *writerData) {
    auto length = size * nmemb;

    writerData->append(data, length);
    return length;
}

static void setMethod(CURL *handle, const std::string &method) {
    if (method == "GET") {
        curl_easy_setopt(handle, CURLOPT_HTTPGET, 1L);
    } else if (method == "POST") {
        curl_easy_setopt(handle, CURLOPT_POST, 1L);
    } else {
        curl_easy_setopt(handle, CURLOPT_CUSTOMREQUEST, method.c_str());
    }
}

static void setPostData(CURL *handle, const std::string &data) {
    curl_easy_setopt(handle, CURLOPT_POSTFIELDS, data.c_str());
    curl_easy_setopt(handle, CURLOPT_POSTFIELDSIZE_LARGE, data.length());
}

static long MinimumSslVersionToCurl(SslVersion version) {
    switch (version) {
        case SslVersion::TLSv1_0:
            return CURL_SSLVERSION_TLSv1_0;
        case SslVersion::TLSv1_1:
            return CURL_SSLVERSION_TLSv1_1;
        case SslVersion::TLSv1_2:
            return CURL_SSLVERSION_TLSv1_2;
        case SslVersion::TLSv1_3:
            return CURL_SSLVERSION_TLSv1_3;

        default:
            return CURL_SSLVERSION_TLSv1_2;
    }
}

ApiResponse ApiClient::callApi(
        const std::string &path,
        const std::string &method,
        const std::map<std::string, std::string, std::less<>> &queryParams,
        const std::map<std::string, std::string, std::less<>> &headerParams,
        const std::map<std::string, std::string, std::less<>> &formParams,
        const std::string &contentType,
        const std::string &postData) const {
    if (!postData.empty() && !formParams.empty()) {
        throw std::invalid_argument("Cannot have body and form params");
    }

    CurlHandle handle;
    CURL *curlHandle = handle.getCurlHandle();

    if (curlHandle == nullptr) {
        throw std::bad_alloc();
    }

    for (const auto &[key, value] : headerParams) {
        std::string header = key + ": " + value;

        handle.AppendHeader(header.c_str());
    }

    if (contentType.empty()) {
        handle.AppendHeader("Content-Type: application/json");
    } else {
        std::string header = "Content-Type:" + contentType;

        handle.AppendHeader(header.c_str());
    }

    if (!method.empty()) {
        setMethod(curlHandle, method);
    }

    /* CURLOPT_POSTFIELDS doesn't copy the string, so retain it until request complete */
    std::string formattedFormParams;

    if (!formParams.empty()) {
        if (contentType == "application/x-www-form-urlencoded") {
            formattedFormParams = CreateUrlEncodedParameterString(curlHandle, formParams);
            setPostData(curlHandle, formattedFormParams);
        } else {
          throw std::invalid_argument("Unsupported content type for form parameters");
        }
    }

    if (m_Configuration->getBaseUrl().rfind("https", 0) == 0) {
        const auto &clientCert = m_Configuration->getClientCert();
        const auto &clientKey = m_Configuration->getClientKey();
        const auto &caCert = m_Configuration->getCACert();

        curl_easy_setopt(curlHandle, CURLOPT_SSLVERSION,
            MinimumSslVersionToCurl(m_Configuration->getMinimumTls()));

        if (!clientCert.empty()) {
            curl_easy_setopt(curlHandle, CURLOPT_SSLCERT, clientCert.c_str());
        }

        if (!clientKey.empty()) {
            curl_easy_setopt(curlHandle, CURLOPT_SSLKEY, clientKey.c_str());
        }

        if (!caCert.empty()) {
            curl_easy_setopt(curlHandle, CURLOPT_CAINFO, caCert.c_str());
        }

        if (m_Configuration->getSkipTlsVerify()) {
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYHOST, 0L);
        } else {
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYPEER, 1L);
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYHOST, 2L);
        }
    }

    {{#hasAuthMethods}}
    {{#authMethods}}
    {{#isApiKey}}
    // this would only be generated for apiKey authentication
    const auto &apiKeys = m_Configuration->getApiKeys();
    if (apiKeys.size() > 0) {
        for (const auto &[key, value] : apiKeys) {
            std::string apiKey = key + ": " + value;

            handle.AppendHeader(apiKey.c_str());
        }
    }
    {{/isApiKey}}
    {{/authMethods}}
    {{/hasAuthMethods}}

    std::string url =
        BuildTargetUrl(curlHandle, m_Configuration->getBaseUrl(), path, queryParams);
    std::string responseData;

    curl_easy_setopt(curlHandle, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curlHandle, CURLOPT_WRITEFUNCTION, writeDataCallback);
    curl_easy_setopt(curlHandle, CURLOPT_WRITEDATA, &responseData);
    curl_easy_setopt(curlHandle, CURLOPT_HTTPHEADER, handle.getHeaders());
    curl_easy_setopt(curlHandle, CURLOPT_VERBOSE,
                    0L);  // Set to 1 to enable debug

    {{#hasAuthMethods}}
    {{#authMethods}}
    {{#isBasic}}
    // this would only be generated for basic authentication:
    if (!m_Configuration->getUsername().empty() &&
            !m_Configuration->getPassword().empty()) {
        std::string authToken = m_Configuration->getUsername() + ":" +
                                m_Configuration->getPassword();

        curl_easy_setopt(curlHandle, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);
        curl_easy_setopt(curlHandle, CURLOPT_USERPWD, authToken.c_str());
    }
    {{/isBasic}}
    {{#isOAuth}}
    // this would only be generated for OAuth2 authentication
    const auto &accessToken = m_Configuration->getAccessToken();
    if (!accessToken.empty()) {
        // curl_easy_setopt(curlHandle, CURLOPT_HTTPAUTH, CURLAUTH_BEARER);
        curl_easy_setopt(curlHandle, CURLOPT_XOAUTH2_BEARER, accessToken.c_str());
    }
    {{/isOAuth}}
    {{/authMethods}}
    {{/hasAuthMethods}}

    if (!postData.empty()) {
        setPostData(curlHandle, postData);
    }

    std::array<char, CURL_ERROR_SIZE> errorBuffer{};

    curl_easy_setopt(curlHandle, CURLOPT_ERRORBUFFER, errorBuffer.data());

    auto res = curl_easy_perform(curlHandle);

    ApiResponse response;

    if (res == CURLE_OK) {
        long responseCode = 0;

        curl_easy_getinfo(curlHandle, CURLINFO_RESPONSE_CODE, &responseCode);
        response.setHttpStatus(responseCode);
        response.setData(std::move(responseData));
    } else {
        response.setError(res, errorBuffer.data());
    }

    return response;
}

void ApiClient::setupGlobalEnv() {
    curl_global_init(CURL_GLOBAL_ALL);
}

void ApiClient::cleanupGlobalEnv() {
    curl_global_cleanup();
}

{{#apiNamespaceDeclarations}}
}
{{/apiNamespaceDeclarations}}
