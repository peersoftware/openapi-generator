{{>licenseInfo}}
{{#models}}{{#model}}
{{#isEnum}}
{{^isNumeric}}
#include <string>
#include <string_view>
{{/isNumeric}}
{{/isEnum}}
#include "{{packageName}}/model/{{classFilename}}.h"

{{#modelNamespaceDeclarations}}
namespace {{this}} {
{{/modelNamespaceDeclarations}}

{{#isEnum}}

namespace {
using EnumUnderlyingType = {{#isNumeric}}int64_t{{/isNumeric}}{{^isNumeric}}std::string{{/isNumeric}};

{{classname}}::e{{classname}} toEnum({{#isNumeric}}int64_t{{/isNumeric}}{{^isNumeric}}std::string_view{{/isNumeric}} val) {
{{#allowableValues}}
{{#isNumeric}}
    switch (val) {
    {{#enumVars}}
    case {{value}}:
        return {{classname}}::e{{classname}}::{{classname}}_{{name}};
    {{#-last}}
    default:
        break;
    {{/-last}}
    {{/enumVars}}
    }
{{/isNumeric}}
{{^isNumeric}}
    {{#enumVars}}
    if (val == "{{{value}}}")
        return {{classname}}::e{{classname}}::{{classname}}_{{name}};
    {{/enumVars}}
{{/isNumeric}}
{{/allowableValues}}
    return {};
}

EnumUnderlyingType fromEnum({{classname}}::e{{classname}} e) {
{{#allowableValues}}
    switch (e) {
{{#enumVars}}
    case {{classname}}::e{{classname}}::{{classname}}_{{name}}:
        return {{#isNumeric}}{{value}}{{/isNumeric}}{{^isNumeric}}"{{value}}"{{/isNumeric}};
{{#-last}}
    default:
        break;
{{/-last}}
{{/enumVars}}
    }
{{/allowableValues}}
    return {};
}
}

nlohmann::json {{classname}}::toJson() const {
    auto val = fromEnum(m_value);
    return nlohmann::json(val);
}

bool {{classname}}::fromJson(const nlohmann::json& val) {
    m_value = toEnum(val.get<EnumUnderlyingType>());
    return true;
}

{{classname}}::e{{classname}} {{classname}}::getValue() const {
   return m_value;
}

{{^isNumeric}}
std::string {{classname}}::getValueString() const {
    return fromEnum(m_value);
}
{{/isNumeric}}

void {{classname}}::setValue({{classname}}::e{{classname}} const value) {
   m_value = value;
}

{{/isEnum}}

{{^isEnum}}

nlohmann::json {{classname}}::toJson() const {
    {{#parent}}
    nlohmann::json val = this->{{{.}}}::toJson();
    {{/parent}}
    {{^parent}}
    nlohmann::json val = nlohmann::json::object();
    {{/parent}}
    {{#vars}}{{^isInherited}}
    if (m_{{name}}IsSet) {
        val["{{baseName}}"] = ModelBase::toJson(m_{{name}});
    }{{/isInherited}}{{/vars}}

    return val;
}

bool {{classname}}::fromJson(const nlohmann::json& val) {
    bool ok = true;
    {{#parent}}
    ok &= this->{{{.}}}::fromJson(val);
    {{/parent}}
    {{#vars}}{{^isInherited}}
    if (val.contains("{{baseName}}")) {
        const nlohmann::json& fieldValue = val.at("{{baseName}}");
        if (!fieldValue.is_null()) {
            {{{dataType}}} refVal_{{setter}};
            ok &= ModelBase::fromJson(fieldValue, refVal_{{setter}});
            {{setter}}(refVal_{{setter}});
        }
    }{{/isInherited}}{{/vars}}
    return ok;
}

{{#vars}}
{{^isInherited}}
{{#vendorExtensions.x-cpp-is-class}}
const {{{dataType}}}& {{classname}}::{{getter}}() const {
{{/vendorExtensions.x-cpp-is-class}}
{{^vendorExtensions.x-cpp-is-class}}
{{{dataType}}} {{classname}}::{{getter}}() const {
{{/vendorExtensions.x-cpp-is-class}}
    return m_{{name}};
}

{{#vendorExtensions.x-cpp-is-class}}
{{#vendorExtensions.x-cpp-is-std-string}}
void {{classname}}::{{setter}}(std::string_view value) {
{{/vendorExtensions.x-cpp-is-std-string}}
{{^vendorExtensions.x-cpp-is-std-string}}
void {{classname}}::{{setter}}(const {{{dataType}}}& value) {
{{/vendorExtensions.x-cpp-is-std-string}}
{{/vendorExtensions.x-cpp-is-class}}
{{^vendorExtensions.x-cpp-is-class}}
void {{classname}}::{{setter}}({{{dataType}}} value) {
{{/vendorExtensions.x-cpp-is-class}}
    m_{{name}} = value;
    m_{{name}}IsSet = true;
}

bool {{classname}}::{{nameInCamelCase}}IsSet() const {
    return m_{{name}}IsSet;
}

void {{classname}}::unset{{name}}() {
    m_{{name}}IsSet = false;
}
{{/isInherited}}
{{/vars}}
{{/isEnum}}
{{#modelNamespaceDeclarations}}
}
{{/modelNamespaceDeclarations}}


{{/model}}
{{/models}}
