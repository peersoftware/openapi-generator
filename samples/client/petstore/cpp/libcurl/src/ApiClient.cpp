/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppLibcurlOpenAPIClient/ApiClient.h"

#define CURL_NO_OLDIES
#include <curl/curl.h>

#include <array>
#include <functional>
#include <limits>
#include <sstream>
#include <stdexcept>

#include "CppLibcurlOpenAPIClient/ModelBase.h"

class CurlHandle {
public:
    CurlHandle() { m_handle = curl_easy_init(); }
    ~CurlHandle() {
        curl_easy_cleanup(m_handle);
        curl_slist_free_all(m_headers);
    }

    CurlHandle(CurlHandle const &) = delete;
    CurlHandle(CurlHandle &&) = delete;
    CurlHandle& operator=(CurlHandle const &) = delete;
    CurlHandle& operator=(CurlHandle &&) = delete;

    void AppendHeader(const char *header) {
        m_headers = curl_slist_append(m_headers, header);
    }

    CURL *getCurlHandle() { return m_handle; }
    struct curl_slist *getHeaders() {
        return m_headers;
    }

private:
    CURL *m_handle{nullptr};
    struct curl_slist *m_headers{nullptr};
};

namespace org::openapitools::client::api {

using namespace org::openapitools::client::model;

ApiClient::ApiClient(std::shared_ptr<const ApiConfiguration> configuration )
    : m_Configuration(configuration) {
}

std::shared_ptr<const ApiConfiguration> ApiClient::getConfiguration() const {
    return m_Configuration;
}
void ApiClient::setConfiguration(std::shared_ptr<const ApiConfiguration> configuration) {
    m_Configuration = configuration;
}


std::string ApiClient::parameterToString(std::string value) {
    return value;
}

std::string ApiClient::parameterToString(int32_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(uint32_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(int64_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(uint64_t value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(float value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(double value) {
    return std::to_string(value);
}

std::string ApiClient::parameterToString(bool value) {
    return value ? "true" : "false";
}

static std::string urlEscape(CURL *handle, const std::string &str) {
    auto escaped = curl_easy_escape(handle, str.c_str(), static_cast<int>(str.length()));

    if (escaped == nullptr) {
        return "";
    }

    std::string result;

    try {
        result = escaped;
    } catch (const std::bad_alloc &) {
        curl_free(escaped);
        throw;
    }

    curl_free(escaped);
    return result;
}

static std::string CreateUrlEncodedParameterString(CURL *handle,
        const std::map<std::string, std::string, std::less<>> &params) {
    std::string paramsStr;

    for (const auto &[key, value] : params) {
        if (!paramsStr.empty()) {
            paramsStr += "&";
        }

        paramsStr += urlEscape(handle, key);

        if (!value.empty()) {
            paramsStr += "=" + urlEscape(handle, value);
        }
    }

    return paramsStr;
}

static std::string BuildTargetUrl(CURL *handle,
        const std::string &base, const std::string &path,
        const std::map<std::string, std::string, std::less<>> &queryParams) {
    std::string url = base + path;

    if (!queryParams.empty()) {
        url += "?" + CreateUrlEncodedParameterString(handle, queryParams);
    }

    return url;
}

static size_t writeDataCallback(const char *data, size_t size, size_t nmemb,
        std::string *writerData) {
    auto length = size * nmemb;

    writerData->append(data, length);
    return length;
}

static void setMethod(CURL *handle, const std::string &method) {
    if (method == "GET") {
        curl_easy_setopt(handle, CURLOPT_HTTPGET, 1L);
    } else if (method == "POST") {
        curl_easy_setopt(handle, CURLOPT_POST, 1L);
    } else if (method == "PUT") {
        curl_easy_setopt(handle, CURLOPT_PUT, 1L);
    } else {
        curl_easy_setopt(handle, CURLOPT_CUSTOMREQUEST, method.c_str());
    }
}

static void setPostData(CURL *handle, const std::string &data) {
    curl_easy_setopt(handle, CURLOPT_POSTFIELDS, data.c_str());
    curl_easy_setopt(handle, CURLOPT_POSTFIELDSIZE_LARGE, data.length());
}

ApiResponse ApiClient::callApi(
        const std::string &path,
        const std::string &method,
        const std::map<std::string, std::string, std::less<>> &queryParams,
        const std::map<std::string, std::string, std::less<>> &headerParams,
        const std::map<std::string, std::string, std::less<>> &formParams,
        const std::string &contentType,
        const std::string &postData) const {
    if (!postData.empty() && !formParams.empty()) {
        throw std::invalid_argument("Cannot have body and form params");
    }

    CurlHandle handle;
    CURL *curlHandle = handle.getCurlHandle();

    if (curlHandle == nullptr) {
        throw std::bad_alloc();
    }

    for (const auto &[key, value] : headerParams) {
        std::string header = key + ": " + value;

        handle.AppendHeader(header.c_str());
    }

    if (contentType.empty()) {
        handle.AppendHeader("Content-Type: application/json");
    } else {
        std::string header = "Content-Type:" + contentType;

        handle.AppendHeader(header.c_str());
    }

    if (!method.empty()) {
        setMethod(curlHandle, method);
    }

    /* CURLOPT_POSTFIELDS doesn't copy the string, so retain it until request complete */
    std::string formattedFormParams;

    if (!formParams.empty()) {
        if (contentType == "application/x-www-form-urlencoded") {
            formattedFormParams = CreateUrlEncodedParameterString(curlHandle, formParams);
            setPostData(curlHandle, formattedFormParams);
        } else {
          throw std::invalid_argument("Unsupported content type for form parameters");
        }
    }

    if (m_Configuration->getBaseUrl().rfind("https", 0) == 0) {
        const auto &clientCert = m_Configuration->getClientCert();
        const auto &clientKey = m_Configuration->getClientKey();
        const auto &caCert = m_Configuration->getCACert();

        if (!clientCert.empty()) {
            curl_easy_setopt(curlHandle, CURLOPT_SSLCERT, clientCert.c_str());
        }

        if (!clientKey.empty()) {
            curl_easy_setopt(curlHandle, CURLOPT_SSLKEY, clientKey.c_str());
        }

        if (!caCert.empty()) {
            curl_easy_setopt(curlHandle, CURLOPT_CAINFO, caCert.c_str());
        }

        if (m_Configuration->getSkipTlsVerify()) {
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYPEER, 0L);
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYHOST, 0L);
        } else {
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYPEER, 1L);
            curl_easy_setopt(curlHandle, CURLOPT_SSL_VERIFYHOST, 2L);
        }
    }

    // this would only be generated for apiKey authentication
    const auto &apiKeys = m_Configuration->getApiKeys();
    if (apiKeys.size() > 0) {
        for (const auto &[key, value] : apiKeys) {
            std::string apiKey = key + ": " + value;

            handle.AppendHeader(apiKey.c_str());
        }
    }

    std::string url =
        BuildTargetUrl(curlHandle, m_Configuration->getBaseUrl(), path, queryParams);
    std::string responseData;

    curl_easy_setopt(curlHandle, CURLOPT_URL, url.c_str());
    curl_easy_setopt(curlHandle, CURLOPT_WRITEFUNCTION, writeDataCallback);
    curl_easy_setopt(curlHandle, CURLOPT_WRITEDATA, &responseData);
    curl_easy_setopt(curlHandle, CURLOPT_HTTPHEADER, handle.getHeaders());
    curl_easy_setopt(curlHandle, CURLOPT_VERBOSE,
                    0L);  // Set to 1 to enable debug

    // this would only be generated for OAuth2 authentication
    const auto &accessToken = m_Configuration->getAccessToken();
    if (!accessToken.empty()) {
        // curl_easy_setopt(curlHandle, CURLOPT_HTTPAUTH, CURLAUTH_BEARER);
        curl_easy_setopt(curlHandle, CURLOPT_XOAUTH2_BEARER, accessToken.c_str());
    }

    if (!postData.empty()) {
        setPostData(curlHandle, postData);
    }

    std::array<char, CURL_ERROR_SIZE> errorBuffer{};

    curl_easy_setopt(curlHandle, CURLOPT_ERRORBUFFER, errorBuffer.data());

    auto res = curl_easy_perform(curlHandle);

    ApiResponse response;

    if (res == CURLE_OK) {
        long responseCode = 0;

        curl_easy_getinfo(curlHandle, CURLINFO_RESPONSE_CODE, &responseCode);
        response.setHttpStatus(responseCode);
        response.setData(std::move(responseData));
    } else {
        response.setError(res, errorBuffer.data());
    }

    return response;
}

void ApiClient::setupGlobalEnv() {
    curl_global_init(CURL_GLOBAL_ALL);
}

void ApiClient::cleanupGlobalEnv() {
    curl_global_cleanup();
}

}
